#include "error_handler.h"

void errorHandlerInit( ErrorHandler * e, int redirect_to_stderr ) {
    e->redirect_to_stderr = redirect_to_stderr;

    if( e->redirect_to_stderr ) {
        fprintf( stderr, "Redirecting debug logs to stderr." );
        e->f_err_log = stderr;
    }
    else {
        e->f_err_log = fopen("./debug.log", "a");

        if( !e->f_err_log ) {
            e->initialized = 0;

            printf( "\nWARNING: errorHandlerInit(): Cannot open debug.txt for appending. Press Enter.\n");

            getchar();
        }
    }
    e->initialized = 1;

    return;
}

void errorHandlerShutdown( ErrorHandler * e ) {
    if( (!e->redirect_to_stderr) && (e->f_err_log) )  {
        fclose(e->f_err_log);
	//TODO debugging segfaults when quitting in linux
    }

    return;
}


/*  Main error-logging function. Tag message with date and time, and append a
    newline to the end. The *fprintf functions are wrapped in another function
    because va_start / va_end do not like to be nested.                         */

void errLog( char * formatted_string, ... ) {

    if( !error_handler.initialized ) {
        // Can't write anything if no valid FILE handle.
        return;
    }

    va_list args;
    va_start( args, formatted_string );

    errLogVaList( formatted_string, args );

    va_end(args);

    return;
}

void errQuit( char * formatted_string, ...  ) {

    va_list args;
    va_start( args, formatted_string );

    errLogVaList( formatted_string, args );
    errLogVaList( "errQuit(): Bad program termination.", args );

    // Try to close f_err_log so that messages are flushed prior to crashing.
    errorHandlerShutdown( &error_handler );

    // Try to shut down Curses gracefully.
    // Commented out as this causes a segfault.
    //endwin();

    // Try to inform of the crash via stdio.
    // (Can't do this while still in Curses mode)
    //printf( "errQuit() caused a program termination. Attempted to flush debug.txt which may have messages related to the crash.\n\nPress Enter to quit\n");
    //getchar();


    // If you ever do malloc counting, you could try freeing allocated pointers here.

    va_end(args);

    // Force close.

    exit(1);

    return;
}

/* See the C FAQ for more info about wrapping va_args:
   http://c-faq.com/varargs/handoff.html               */
void errLogVaList( char * formatted_string, va_list args ) {

    time_t t;
    time(&t);

    /* Use a temporary buffer to clip off the newline generated by ctime().
       ctime() should return a string of roughly 25 characters, but may return
       additional chars if the year is greater than 9999. Or so I hear.        */
    #define ERRLOG_TEMP_BUFFER_LEN 64
    char temp_buffer[ERRLOG_TEMP_BUFFER_LEN];
    snprintf( temp_buffer, ERRLOG_TEMP_BUFFER_LEN, ctime(&t) );
    temp_buffer[strlen(temp_buffer) - 1] = 0x0;

    // 1/3 Print time
    fprintf( error_handler.f_err_log, "%s: ", temp_buffer );

    // 2/3 Print the actual error message
    vfprintf( error_handler.f_err_log, formatted_string, args );

    // 3/3 Print newline
    fprintf( error_handler.f_err_log, "\n" );

    return;
}
